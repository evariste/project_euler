
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
# numbers are all figurate (polygonal) numbers and are generated by
# the following formulae:

# Triangle              P_3,n = n(n+1)/2                1, 3, 6, 10, 15, ...
# Square                P_4,n = n^2                     1, 4, 9, 16, 25, ...
# Pentagonal            P_5,n = n(3n-1)/2               1, 5, 12, 22, 35, ...
# Hexagonal             P+6,n = n(2n-1)                 1, 6, 15, 28, 45, ...
# Heptagonal            P_7,n = n(5n-3)/2               1, 7, 18, 34, 55, ...
# Octagonal             P_8,n = n(3n-2)                 1, 8, 21, 40, 65, ...

# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
# three interesting properties.

#     The set is cyclic, in that the last two digits of each number is
#     the first two digits of the next number (including the last
#     number with the first).

#     Each polygonal type: triangle (P_3,127 = 8128), square
#     (P_4,91 = 8281), and pentagonal (P_5,44 = 2882), is represented by a
#     different number in the set.

#     This is the only set of 4-digit numbers with this property.

# Find the sum of the only ordered set of six cyclic 4-digit numbers
# for which each polygonal type: triangle, square, pentagonal,
# hexagonal, heptagonal, and octagonal, is represented by a different
# number in the set.

# P_3,n = n (1 n + 1 ) / 2
# p_4,n = n (2 n + 0 ) / 2
# p_5,n = n (3 n - 1 ) / 2
# p_6,n = n (4 n - 2 ) / 2
# p_7,n = n (5 n - 3 ) / 2
# p_8,n = n (6 n - 4 ) / 2

import sys
import networkx as nx


def p_k_n(k, n):
  return n * ( (k-2) * n + 4 - k ) / 2

# Use bits to represent which type of sequence each number is a part
# of. Some numbers may be in more than one sequence.
polyType = {}

G = nx.DiGraph()


def buildCycle(currentPath, stepsLeft, typesCovered):
  """
  currentPath : list of nodes so far, starting at some node or other.
  stepsLeft: How many more nodes needed to make the required cycle.
  typesCovered : Which types of polygonal numbers have we encountered
  on the way.
  """
  ns = G.neighbors(currentPath[-1])
  start = currentPath[0]

  if ns == []:
    # No successors to the current node, can't be in a cycle
    return []

  if stepsLeft == 0:
    # Can we connect with the starting point.
    if start in ns:
      return currentPath
    else:
      return []

  typesNeeded = ~typesCovered

  ps = []
  for n in ns:
    if typesNeeded & polyType[n] > 0:
      p = buildCycle(currentPath + [n], stepsLeft - 1, typesCovered | polyType[n])
      if p != []:
        #return p
        ps = ps + p 

  return ps

###################################################################

def main(*args):

  maxInd = 1
  while p_k_n(3, maxInd) < 10000:
    maxInd += 1

  print 'max index ' , maxInd

  for k in range(3,9):
    polyMask = 2 ** k

    curr = [ p_k_n(k, n) for n in range(maxInd) \
               if p_k_n(k,n) > 999 and p_k_n(k,n) < 10000]

    print curr
    print

    for val in curr:
      if val in polyType:
        polyType[val] = polyType[val] | polyMask
      else:
        polyType[val] = polyMask


  vals = polyType.keys()

  for a in vals:
    for b in vals:

      if a % 100 == b / 100:
        # check how many types are covered if a values first two digits
        # are the same as the last two.
#        if a == b and len( filter(lambda x : x == '1' , bin(polyType[a])[2:] ) ):
          # Avoid self-looping node if only one polygon type is represented.
#          continue

        G.add_edge(a,b)


  print G.order(), G.number_of_edges(), G.number_of_selfloops()


  cached = []
  size = 6

  for n in G:
    p = buildCycle([n], size - 1, polyType[n])
    if p != []:
      print p

#     if p != []:
#       for i in range(len(p)):
#         pp = p[i:] + p[:i]
#         found = False
#         for c in cached:
#           if c == pp: found = True
#         if found: break
#       if found: continue
#       cached = cached + [ p ]

#       print n, ': ',  p , sum(p)
#       for x in p:
#         s = bin(polyType[x])[2:-3]
#         print s.rjust(6, '0'),
#       print
#       print
    
      

if __name__ == '__main__':
  sys.exit(main(*sys.argv))


###################################################################


